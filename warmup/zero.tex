\documentclass[12pt,a4paper]{scrartcl}

%\usepackage{algorithmic}    % Typesetting for pseudocode
%\usepackage{algorithm}      % Formatting for general algorithm blocks
\usepackage{fancyhdr}       % Gives fancy header
\usepackage{mdwlist}        % List related commands
\usepackage{url}            % Nicer URL formatting
\usepackage{new3151defs}    % COMP[39]151 defs
\usepackage{fancyvrb}

% Automata package
\usepackage{tikz}
\usetikzlibrary{automata, positioning}

% Page header
%\pagestyle{fancy}
%\lhead{COMP[39]151 Warmup Assignment
%\rhead{Timothy Wiley, z3109831}

% Line spacing 1.6 for 'double'
%\linespread{2}

% Declare commonly used graphic extensions and precedence
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\begin{document}

\title{COMP[39]151 Warm-up assignment}
\author{Aditya Keswani (z3242379) \\ 
        \texttt{akeswani@cse.unsw.edu.au} \\ 
        and \\ 
        Timothy Wiley (z3109831) \\
        \texttt{timothyw@cse.unsw.edu.au} }

\maketitle

\section{Question 1}

\subsection{Algorithms ZeroA, ZeroB and ZeroC}

\subsubsection{Promela implementations}

\textbf{ZeroA}
\lstinputlisting{zeroA.pml}

\textbf{ZeroB}
\lstinputlisting{zeroB.pml}

\textbf{ZeroC}
\lstinputlisting{zeroC.pml}

\subsubsection{LTL formula}

The LTL formula we use to test the correctness of these algorithms is:
\begin{align} \Always ( ( \Eventually found ) \And ( found \Implies \Always found ) ) \end{align}

Found is only set to true when one of the processes finds the zero. Therefore, the first part of this formula, 
\begin{align} \Eventually found \end{align}
ensures that one of the processes does eventually find the zero. 

The second part of this formula, 
\begin{align} found \Implies \Always found \end{align} 
ensures that after one of the processes finds the zero and sets found to true, it will remain true. Since found is the guard on the loop in both processes, this means that both processes will exit their loops and terminate after this occurs.

Finally, the outer \(\Always\) ensures that these parts of the formula are satisfied in all states. Without this, the formula would only need to be satisfied in one state for the program to pass checking.

\subsubsection{Spin output}
\textbf{ZeroA}
\VerbatimInput{output/zeroAOutput}
\textbf{ZeroB}
\VerbatimInput{output/zeroBOutput}
\textbf{ZeroC}
\VerbatimInput{output/zeroCOutput}

\subsection{Algorithms ZeroD and ZeroE}

\subsubsection{Promela implementations}

\textbf{ZeroD}
\lstinputlisting{zeroD.pml}

\textbf{ZeroE}
\lstinputlisting{zeroE.pml}

\subsubsection{LTL formula}

The LTL formula we use to test the correctness of these algorithms is:
\begin{align} 
\Always ( ( \Eventually found ) \And ( found \Implies \Always found )\notag\\
\And ( P@pTurnChange \Implies \Eventually P@pAfterTurnChange )\\
\And ( Q@qTurnChange \Implies \Eventually Q@qAfterTurnChange ) )\notag
\end{align}

The first two parts of this formula are the same as those used for algorithms ZeroA, ZeroB and ZeroC and are explained above. However, these cannot prevent a program from permanently blocking inside its await statement (and never terminating) after found has been set to true. The latter two parts of the formula,
\begin{align} 
( P@pTurnChange \Implies \Eventually P@pAfterTurnChange )\notag\\
\And ( Q@qTurnChange \Implies \Eventually Q@qAfterTurnChange ) 
\end{align}
prevent this by ensuring that if a process enters its await statement, it eventually exits it.

\subsubsection{Spin output}

\textbf{ZeroD}
\VerbatimInput{output/zeroDOutput}

\textbf{ZeroE}
\VerbatimInput{output/zeroEOutput}

\section{Question 2}


\end{document}
